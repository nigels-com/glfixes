Name

    ARB_vertex_buffer_object

Name Strings

    GL_ARB_vertex_buffer_object
    GLX_ARB_vertex_buffer_object

Contributors

    Ben Ashbaugh
    Bob Beretta
    Pat Brown
    Cass Everitt
    Mandar Godse
    James Jones
    John Kessenich
    Dale Kirkland
    Jon Leech
    Bill Licea-Kane
    Barthold Lichtenbelt
    Bimal Poddar
    Thomas Roell
    Ian Romanick
    Jeremy Sandmel
    Jon Paul Schelter
    John Stauffer
    Nick Triantos
    Daniel Vogel

Contact

    Rick Hammerstone, AMD (rick.hammerstone 'at' amd.com)
    Matt Craighead, NVIDIA Corporation (mcraighead 'at' nvidia.com)
    Kurt Akeley, NVIDIA Corporation (kakeley 'at' nvidia.com)

Notice

    Copyright (c) 2003-2013 The Khronos Group Inc. Copyright terms at
        http://www.khronos.org/registry/speccopyright.html

IP Status

    None.

Status

    Complete. Approved by ARB on February 12, 2003.

Version

    Last Modified Date: October 25, 2010
    Revision: 0.99.6

Number

    ARB Extension #28

Dependencies

    Written based on the wording of the OpenGL 1.4 specification.

    GL_ARB_vertex_blend affects the definition of this extension.

    GL_ARB_vertex_program affects the definition of this extension.

    GL_EXT_vertex_shader affects the definition of this extension.

    GLX_ARB_create_context affects the behavior of this extension.

Overview

    This extension defines an interface that allows various types of data
    (especially vertex array data) to be cached in high-performance
    graphics memory on the server, thereby increasing the rate of data
    transfers.

    Chunks of data are encapsulated within "buffer objects", which
    conceptually are nothing more than arrays of bytes, just like any
    chunk of memory.  An API is provided whereby applications can read
    from or write to buffers, either via the GL itself (glBufferData,
    glBufferSubData, glGetBufferSubData) or via a pointer to the memory.

    The latter technique is known as "mapping" a buffer.  When an
    application maps a buffer, it is given a pointer to the memory.  When
    the application finishes reading from or writing to the memory, it is
    required to "unmap" the buffer before it is once again permitted to
    use that buffer as a GL data source or sink.  Mapping often allows
    applications to eliminate an extra data copy otherwise required to
    access the buffer, thereby enhancing performance.  In addition,
    requiring that applications unmap the buffer to use it as a data
    source or sink ensures that certain classes of latent synchronization
    bugs cannot occur.

    Although this extension only defines hooks for buffer objects to be
    used with OpenGL's vertex array APIs, the API defined in this
    extension permits buffer objects to be used as either data sources or
    sinks for any GL command that takes a pointer as an argument.
    Normally, in the absence of this extension, a pointer passed into the
    GL is simply a pointer to the user's data.  This extension defines
    a mechanism whereby this pointer is used not as a pointer to the data
    itself, but as an offset into a currently bound buffer object.  The
    buffer object ID zero is reserved, and when buffer object zero is
    bound to a given target, the commands affected by that buffer binding
    behave normally.  When a nonzero buffer ID is bound, then the pointer
    represents an offset.

    In the case of vertex arrays, this extension defines not merely one
    binding for all attributes, but a separate binding for each
    individual attribute.  As a result, applications can source their
    attributes from multiple buffers.  An application might, for example,
    have a model with constant texture coordinates and variable geometry.
    The texture coordinates might be retrieved from a buffer object with
    the usage mode "STATIC_DRAW", indicating to the GL that the
    application does not expect to update the contents of the buffer
    frequently or even at all, while the vertices might be retrieved from
    a buffer object with the usage mode "STREAM_DRAW", indicating that
    the vertices will be updated on a regular basis.

    In addition, a binding is defined by which applications can source
    index data (as used by DrawElements, DrawRangeElements, and
    MultiDrawElements) from a buffer object.  On some platforms, this
    enables very large models to be rendered with no more than a few
    small commands to the graphics device.

    It is expected that a future extension will allow sourcing pixel data
    from and writing pixel data to a buffer object.

Issues

    What should this extension be called?

        RESOLVED: By unanimous consent among the working group members,
        the name was chosen to be "ARB_vertex_buffer_object".  A large
        number of other names were considered throughout the lifetime of
        the proposal, especially "vertex_array_object" (originally),
        "buffer_object" (later on), and "memory_object" (near the end),
        but the name "vertex_buffer_object" was ultimately chosen.

        In particular, this name emphasizes not only that we have created
        a new type of object that encapsulates arbitrary data (buffer
        objects), but also, in particular, that these objects are used in
        this extension to source vertex data.  The name also is
        intentionally similar to "vertex buffers", although it should be
        emphasized that there is no such thing as a "vertex buffer" in
        the terminology of this extension.  The term "buffer object" is
        the correct noun.

    How is this extension different from ATI_vertex_array_object plus
    ATI_map_object_buffer?

        The following summarizes the major differences.
        - VAOs renamed to "buffer objects", to signify that they can be
          used for more than just vertex data.  Other renaming and API
          changes to try to better match OpenGL conventions.
        - The standard GL pointer APIs have been overloaded to be able to
          refer to offsets within these buffers, rather than adding new
          entry points.
        - The usage modes permitted for buffers have been augmented
          significantly, to reflect a broader class of application
          behaviors.
        - A new entry point allows reading back the contents of a buffer
          object.

    How is this extension different from NV_vertex_array_range?

        The following summarizes the major differences.
        - Applications are no longer responsible for memory management
          and synchronization.
        - Applications may still access high-performance memory, but
          this is optional, and such access is more restricted.
        - Buffer changes (glBindBufferARB) are generally expected to
          be very lightweight, rather than extremely heavyweight
          (glVertexArrayRangeNV).
        - A platform-specific allocator such as wgl/glXAllocateMemoryNV
          is no longer required.

    How does this extension relate to NV_pixel_data_range?

        A future extension could be created based on the framework
        created here that would support analogous functionality to that
        provided by NV_pixel_data_range.  Presumably, this extension
        would require little more than two new targets for BindBuffer,
        named (say) UNPACK_PIXELS and PACK_PIXELS.  The lists of commands
        affected by these bindings could easily be taken verbatim out of
        the NV_pixel_data_range specification.

    Should this extension include support for allowing vertex indices
    to be stored in buffer objects?
    
        RESOLVED: YES.  It is easily and cleanly added with just the
        addition of a binding point for the index buffer object.  Since
        our approach of overloading pointers works for any pointer in GL,
        no additional APIs need be defined, unlike in the various
        *_element_array extensions.

        Note that it is expected that implementations may have different
        memory type requirements for efficient storage of indices and
        vertices.  For example, some systems may prefer indices in AGP
        memory and vertices in video memory, or vice versa; or, on
        systems where DMA of index data is not supported, index data must
        be stored in (cacheable) system memory for acceptable
        performance.  As a result, applications are strongly urged to
        put their models' vertex and index data in separate buffers, to
        assist drivers in choosing the most efficient locations.

    Should the layout of an array store be defined at array store
    creation time?

        RESOLVED: NO.  This could provide better performance if the
        client specifies a data type that the hardware doesn't support,
        but this isn't a performance path anyways, and it adds a
        cumbersome interface on top of the extension.

    Should there be some sort of scheme for allowing applications to
    stream vertex data efficiently?

        RESOLVED: YES.  Applications that generate their data on the
        fly end up doing an extra data copy unless they are given a
        pointer into memory that the graphics hardware can DMA from.  The
        performance win from doing this can be significant.

    Should the client be able to retrieve a pointer to a buffer object?

        RESOLVED: YES.  This solves the previous problem.  Since GL
        vertex array formats are already user-visible, this does not
        suffer from the sorts of formatting issues that would arise if
        the GL allowed applications to retrieve pointers to texture
        objects or to the framebuffer.  Synchronization can be a concern,
        but proper usage of this extension will minimize its overhead.

    Should this extension sit on top of the existing vertex array
    implementation, instead of introducing a new set of API calls?

        RESOLVED: YES.  This simplifies the API, and separating out the
        buffer binding from the offset/stride within the buffer leads to
        an elegant "BindBufferARB" command that can be used for other
        parts of GL like the pixel path.

    Should buffer object state overlap with existing vertex array pointer
    state, or should there be new drawing commands, e.g.,
    DrawArrayObject?

        RESOLVED: OVERLAP.  The exponential growth in drawing commands
        is problematic.  Even without this, there is already
        ArrayElement, DrawArrays, DrawElements, DrawRangeElements,
        MultiDrawArrays, and MultiDrawElements.

    Does the buffer binding state push/pop?

        RESOLVED: YES.  It pushes/pops on the client with the rest of
        the vertex array state.  Some revisions of the ATI VAO spec
        listed a push/pop attrib "objbuf", but no new bit was defined;
        all this has been moved into the standard "vertex-array" bit.

        Note that both the user-controlled binding ARRAY_BUFFER_ARB
        binding point and the per-array bindings push and pop.

        Note that additional binding points, such as ones for pixel or
        texture transfers, would not be part of the vertex array state,
        and thus would likely push and pop as part of the pixel store
        (client) state when they are defined.

    How is the decision whether to use the array pointer as an offset or
    as a real pointer made?

        RESOLVED: When the default buffer object (object zero) is
        bound, all pointers behave as real pointers.  When any other
        object is bound, all pointers are treated as offsets.
        Conceptually, one can imagine that buffer object zero is a buffer
        object sitting at base NULL and with an extent large enough that
        it covers all of the system's virtual address space.

        Note that this approach essentially requires that binding points
        be client (not server) state.

    Can buffer objects be shared between contexts in the same way that
    display lists are?

        RESOLVED: YES.  All potentially large OpenGL objects, such as
        display lists and textures, can be shared, and this is an
        important capability.  Note, however, that sharing requires that
        buffer objects be server (not client) state, since it is not
        possible to share client state.

    Should buffer objects be client state or server state?

        RESOLVED: Server state.  Arguments for client state include:

          - Buffer data are stored in client-side format, making server
            storage complex when client and server endianness differ.
          - Vertex arrays are client state.

        These arguments are outweighed by the significant advantages
        of server state, including:

          - Server state can be shared between contexts, and this is
            expected to be an important capability (sharing of texture
            objects is very common).
          - In the case of indirect rendering, performance may be
            very significantly greater for data stored on the server
            side of the wire.

    How is synchronization enforced when buffer objects are shared by
    multiple OpenGL contexts?

        RESOLVED: It is generally the clients' responsibility to
        synchronize modifications made to shared buffer objects.  GL
        implementations will make some effort to avoid deletion of in-use
        buffer objects, but may not be able to ensure this handling.

    What happens if a currently bound buffer object is deleted?

        RESOLVED: Orphan.  To avoid chasing invalid pointers OpenGL
        implementations will attempt to defer the deletion of any buffer
        object until that object is not bound by any client in the share
        list.  It should be possible to implement this behavior
        efficiently in the direct rendering case, but the implementation
        may be difficult/impossible in the indirect rendering case.
        Since synchronization during sharing is a client responsibility,
        this behavior is acceptable.

    Should there be a way to query the data in a buffer object?

        RESOLVED: YES.  Almost all objects in OpenGL are fully
        queriable, and since these objects are simply byte arrays, there
        does not seem to be any reason to do things otherwise here.  The
        primary exceptions to GL queriability are cases where such
        functionality would be extremely burdensome to provide, as is the
        case with display lists.

    Do buffer objects survive screen resolution changes, etc.?

        RESOLVED: YES.  This is not mentioned in the spec, so by
        default they behave just like other OpenGL state, like texture
        objects -- the data is unmodified by external events like
        modeswitches, switching the system into standby or hibernate
        mode, etc.

    What happens to a mapped buffer when a screen resolution change or
    other such window-system-specific system event occurs?

        RESOLVED: The buffer's contents may become undefined.  The
        application will then be notified at Unmap time that the buffer's
        contents have been destroyed.  However, for the remaining
        duration of the map, the pointer returned from Map must continue
        to point to valid memory, in order to ensure that the application
        cannot crash if it continues to read or write after the system
        event has been handled.

    What happens to the pointer returned by MapBufferARB after a call to
    UnmapBufferARB?

        RESOLVED: The pointer becomes totally invalid.  Note that
        drivers are free to move the underlying buffer or even unmap the
        memory, leaving the virtual addresses in question pointing at
        nothing.  Such flexibility is necessary to enable efficient
        implementations on systems with no virtual memory; with limited
        control over virtual memory from graphics drivers; or where
        virtual address space is at a premium.

    Are any of these commands allowed inside Begin/End?

        RESOLVED: NO, with the possible exception of BindBuffer, which
        should not be used inside a Begin/End but will have undefined
        error behavior, like most vertex array commands.

    What happens when an attempt is made to access data outside the
    bounds of the buffer object with a command that dereferences the
    arrays?

        RESOLVED: ALLOW PROGRAM TERMINATION.  In the event of a
        software fallback, bounds checking can become impractical.  Since
        applications don't know the actual address of the buffer object
        and only provide an offset, they can't ever guarantee that
        out-of-bounds offsets will fall on valid memory.  So it's hard to
        do any better than this.

        Of course, such an event should not be able to bring down the
        system, only terminate the program.

    What type should <offset> and <size> arguments use?

        RESOLVED: We define new types that will work well on 64-bit
        systems, analogous to C's "intptr_t".  The new type "GLintptrARB"
        should be used in place of GLint whenever it is expected that
        values might exceed 2 billion.  The new type "GLsizeiptrARB"
        should be used in place of GLsizei whenever it is expected
        that counts might exceed 2 billion.  Both types are defined as
        signed integers large enough to contain any pointer value.  As a
        result, they naturally scale to larger numbers of bits on systems
        with 64-bit or even larger pointers.

        The offsets introduced in this extension are typed GLintptrARB,
        consistent with other GL parameters that must be non-negative,
        but are arithmetic in nature (not uint), and are not sizes; for
        example, the xoffset argument to TexSubImage*D is of type GLint.
        Buffer sizes are typed GLsizeiptrARB.

        The idea of making these types unsigned was considered, but was
        ultimately rejected on the grounds that supporting buffers larger
        than 2 GB was not deemed important on 32-bit systems.

    Should buffer maps be client or server state?

        RESOLVED: Server.  If a buffer is being shared by multiple
        clients, it will also be desirable to share the mappings of that
        buffer.  In cases where the mapping cannot shared (for example,
        in the case of indirect rendering) queries of the map pointer by
        clients other than the one that created the map will return a
        null pointer.

    Should "Unmap" be treated as one word or two?

        RESOLVED: One word.

    Should "usage" be a parameter to BufferDataARB, or specified
    separately using a parameter specification command, e.g.,
    BufferParameteriARB?

        RESOLVED: Parameter to BufferDataARB.  It is desirable for the
        implementation to know the usage when the buffer is initialized,
        so including it in the initialization command makes sense.  This
        avoids manpage notes such as "Please specify the usage before you
        initialize the buffer".

    Should it be possible to change the usage of an initialized buffer?

        RESOLVED: NO.  Unless it is shown that this flexibility is
        necessary, it will be easier for implementations to be efficient
        if usage cannot be changed.  (Except by re-initializing the
        buffer completely.)

    Should we allow for the possibility of multiple simultaneous maps for
    a single buffer?

        RESOLVED: NO.  If multiple maps are allowed, the mapping
        semantics become very difficult to understand and to specify.
        It is also unclear that there are any benefits to offering such
        functionality.  Therefore, only one map per buffer is permitted.

        Note: the limit of one map per buffer eliminates any need for
        "sub-region" mapping.  The single map always maps the entire
        data store of the buffer.

    Should it be an error to render from a currently mapped buffer?

        RESOLVED: YES.  Making this an error rather than undefined makes
        the API much more bulletproof.

    Should it be possible for the application to query the "viability" of
    the data store of a buffer?

        RESOLVED: NO.  UnmapBuffer can return FALSE to indicate this, but
        there is no additional query to check whether the data has been
        lost.  In general, most/all GL state is queriable, unless there
        is a compelling reason otherwise.  However, on examination, it
        appears that there are several compelling reasons otherwise in
        this case.  In particular, the default for this state variable is
        non-obvious (is the data "valid" when no data has been specified
        yet?), and it's unclear when it should be reset (BufferData only?
        BufferSubData?  A successful UnmapBuffer?).  After these issues
        came to light, the query was removed from the spec.

    What should the error behavior of BufferDataARB and MapBufferARB be?

        RESOLVED: BufferDataARB returns no value and sets OUT_OF_MEMORY
        if the buffer could not be created, whereas MapBufferARB returns
        NULL and also sets OUT_OF_MEMORY if the buffer could not be
        mapped.

    Should UnmapBufferARB return a boolean indicating data integrity?

        RESOLVED: YES, since the Unmap is precisely the point at which
        the buffer can no longer be lost.

    How is unaligned data handled?

        RESOLVED: All client restrictions on data alignment must be met,
        and in addition to that, all offsets must be multiples of the
        size of the underlying data type.  So, for example, float data in
        a buffer object must have an offset that is (typically) a
        multiple of 4.  This should make the server implementation
        easier, since this additional rule will guarantee that no 
        alignment checking is required on most platforms.

    Should MapBufferARB return the pointer to the map, or should there be
    a separate call to ask for the pointer?

        RESOLVED: BOTH.  For convenience, MapBufferARB returns a pointer
        or NULL in the event of failure; but since most/all GL state is
        queriable, you can also query the pointer at a later point in
        time.  If the buffer is not mapped, querying the pointer should
        return NULL.

    Should there be one binding point for all arrays or several binding
    points, one for each array?

        RESOLVED: One binding point for all arrays.  Index data uses a
        separate target.

    Should there be a PRESERVE/DISCARD option on BufferSubDataARB?  On
    MapBufferARB?

        RESOLVED: NO, NO.  ATI_vertex_array_object had this option for
        UpdateObjectBufferATI, which is the equivalent of
        BufferSubDataARB, but it's unclear whether this has any utility.
        There might be some utility for MapBufferARB, but forcing the
        user to call BufferDataARB again with a NULL data pointer has
        some advantages of its own, such as forcing the user to respecify
        the size.

    Should there be an option for MapBufferARB that guarantees
    nonvolatile memory?

        RESOLVED: NO.  On systems where volatile memory spaces are a
        concern, there is little or no way to supply nonvolatile memory
        without crippling performance badly.  In some cases, it might
        not even be possible to implement Map except by returning system
        memory.  Systems that do not have problems with volatility are,
        of course, welcome to return TRUE from UnmapBufferARB all the
        time.  If applications want the ease of use that results from not
        having to check for lost data, they can still use BufferDataARB
        and BufferSubDataARB, so the burden is not too great.

    What new usages do we need to add?

        RESOLVED.  We have defined a 3x3 matrix of usages.  The
        pixel-related terms draw, read, and copy are used to distinguish
        between three basic data paths: application to GL (draw), GL to
        application (read), and GL to GL (copy).  The terms stream,
        static, and dynamic are used to identify three data access
        patterns: specify once and use once or perhaps only a few times
        (stream), specify once and use many times (static), and specify
        and use repeatedly (dynamic).

        Note that the "copy" and "read" usage token values will become
        meaningful only when pixel transfer capability is added to
        buffer objects by a (presumed) subsequent extension.

        Note that the data paths "draw", "read", and "copy" are analogous
        in both name and meaning to the GL commands DrawPixels,
        ReadPixels, and CopyPixels, respectively.

    Is it legal C to use pointers as offsets?

        We haven't come to any definitive conclusion about this.  The
        proposal is to convert to pointer as:

            pointer = (char *)NULL + offset;

        And convert back to offset as:

            offset = (char *)pointer - (char *)NULL;

        Varying opinions have been expressed as to whether this is legal,
        although no one could provide an example of a real system where
        any problems would occur.

    Should we add new Offset commands, e.g., VertexOffset, if the pointer
    approach has some compatibility concerns?

        RESOLVED: NO.  The working group voted that the existing pointer-
        as-offset approach is acceptable.

    Which commands are compiled into display lists?

        RESOLVED: None of the commands in this extension are compiled
        into display lists.  The reasoning is that the server may not
        have up-to-date buffer bindings, since BindBuffer is a client
        command.

        Just as without this extension, vertex data is dereferenced
        when ArrayElement, etc. are compiled into a display list.

    Should there be a new command "DiscardAndMapBuffer" that is
    equivalent to BufferDataARB with NULL pointer followed by
    MapBufferARB?

        RESOLVED: NO, no one has come up with a clearly superior proposal
        that everyone can agree on.

     Are any GL commands disallowed when at least one buffer object is
     mapped?

        RESOLVED: NO.  In general, applications may use whatever GL
        commands they wish when a buffer is mapped.  However, several
        other restrictions on the application do apply: the application
        must not attempt to source data out of, or sink data into, a
        currently mapped buffer.  Furthermore, the application may not
        use the pointer returned by Map as an argument to a GL command.
        (Note that this last restriction is unlikely to be enforced in
        practice, but it violates reasonable expectations about how the
        extension should be used, and it doesn't seem to be a very
        interesting usage model anyhow.  Maps are for the user, not for
        the GL.)

        More restrictive rules were considered (for example, "after
        calling MapBuffer, all GL commands except for UnmapBuffer produce
        errors"), but this was considered far too restrictive.  The
        expectation is that an application might map a buffer and start
        filling it in a different thread, but continue to render in its
        main thread (using a different buffer or no buffer at all).  So
        no commands are disallowed simply because a buffer happens to be
        mapped.

    Should the usage and data arguments to BufferDataARB be swapped?

        RESOLVED: NO.  This would be more consistent with other things in
        GL if they were swapped, but no one seems to care.  If we had
        caught this earlier, maybe, but it's just too late.

    How does MultiDrawElements work?

        The language gets a little confusing, but I believe it is quite
        clearly specified in the end.  The argument <indices> to
        MultiDrawElements, which is of type "const void **", is an
        honest-to-goodness pointer to regular old system memory, no
        matter whether a buffer is bound or not.  That memory in turn
        consists of an array of <primcount> pointers.  If no buffer is
        bound, each of those <primcount> pointers is a regular pointer.
        If a buffer is bound, each of those <primcount> pointers is a
        fake pointer that represents an offset in the buffer object.

        If you wanted to put the array of <primcount> offsets in a buffer
        object, you'd have to define a new extension with a new target.

    When is the binding between a buffer object and a specific vertex array
    (e.g., VERTEX_ARRAY_BUFFER_BINDING_ARB) established?

        The array's buffer binding is set when the array pointer is specified.
        Using the vertex array as an example, this is when VertexPointer is
        called.  At that time, the current array buffer binding is used for
        the vertex array.  The current array buffer binding is set by calling
        BindBufferARB with a <target> of ARRAY_BUFFER_ARB.  Changing the
        current array buffer binding does not affect the bindings used by
        already established arrays.

          BindBufferARB(ARRAY_BUFFER_ARB, 1);
          VertexPointer(...);   // vertex array data points to buffer 1
          BindBufferARB(ARRAY_BUFFER_ARB, 2);
          // vertex array data still points to buffer 1

    What happens when a single ArrayElement call within a large sequence of
    ArrayElement calls specifies an element that is outside the range of the
    bound buffer objects?

        UNRESOLVED.  The three suggestions from the ARB meeting are to either
        ignore just that ArrayElement call, set an error bit and ignore all
        ArrayElement calls until End, or treat the ArrayElement call as
        ArrayElement(0).

    How should EnableClientState and DisableClientState be handled when using
    indirect rendering?

        RESOLVED:  EnableVertexAttribArray and DisableVertexAttribArray
        commands are used to inform the server of new enable/disable state.

    When using indirect rendering, how is DrawElements handled when the
    element array is in a buffer object but one or more of the enabled arrays
    are not?

        RESOLVED:  There are two commands that can be used to implement
        DrawElements and related calls.  If all of the data resides on the
        server, the element pointer is set by using a BindBufferToArray
        command with array set to ELEMENT_ARRAY_ATI.  This command is
        followed by the appropriate EnableVertexAttribArray and
        DisableVertexAttribArray calls, making sure to enable the element
        array, and either a DrawElements call or a DrawRangeElements call.

        If any arrays reside on the client, including the element array,
        the sequence is essentially the same except the DrawRangeElements
        protocol must be used.  If the element array resides on the
        server, the client must issue a GetElementRange command to determine
        the range of array data (and the values for 'start' and 'end') that
        must be sent to the server.

    Is a "provoke" flag needed in the ArrayElement command protocol to switch
    between the case where the VERTEX_ARRAY is client-side vs. server-side?
    
        NO.  The server will know whether or not the ArrayElement command
        will provoke a vertex because it knows whether or not a buffer object
        is bound to VERTEX_ARRAY.

    How does the server know which arrays with buffer objects bound are
    enabled in ArrayElement?

        RESOLVED:  The array bindings are configured using BindBuffer and
        BindBufferToArray commands.  The arrays are enabled and disabled
        using EnableVertexAttribArray and DisableVertexAttribArray.

    Can't the server-side array bindings just be sent in a the ARRAY_INFO
    when DrawArrays is called?
    
        NO.  The only way to do that would be to transmit the offset, type,
        size, stride, etc. parameters and the buffer ID.  However, the buffer
        may have been deleted in the meantime.  The binding information must
        be sent when the pointer function (e.g., VertexPointer) is called.

    What about byte-ordering?  The format of the data, and therefore what
    byte-swapping may need to be done, is not know when the data is
    uploaded to the server.  In fact, since it is legal (though probably
    nonsensical) to have the same bytes in the buffer be used as multiple
    datatypes, a single byte-ordering may not exist.  What happens when
    two clients with different byte ordering share one buffer object?  Is
    it valid to not expose the extension if the byte-ordering of the
    client and server do not match?

        RESOLVED:  It is the client's responsibility to convert buffer data
        to and from the server's byte order.  Since only the client knows
        the correct format of the data, and there may be multiple clients
        with different byte orderings sharing a single buffer object, it is
        unreasonable to ask the GL to handle buffer object byte-swapping.
        To avoid errors caused by naive clients attempting to use buffer
        objects without performing the appropriate byte swapping, clients
        must opt in to buffer object support at context creation time using
        the GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB context attrib.  
        If this attribute is not specified and the byte ordering of the client
        and server differ, the VBO extension must not be exposed and the
        maximum context version that can be reported is 1.4.

    Should Enable/DisableVertexAttribArray and VertexAttribPointer handle
    both indexed and legacy arrays?

        RESOLVED: Yes.  Send GL_NONE for <array> when referring to
        indexed arrays.  For all other values of <array> except
        GL_TEXTURE??, <index> is ignored.  For GL_TEXTURE??, see next
        issue.

    How is the client-side state client active texture, needed by
    glTexCoordPointer, communicated to the server?

        RESOLVED: Send the active texture index using the <index>
        parameter normally used for indexed arrays.  The value of
        <index> will be an offset from GL_TEXTURE0.

        OTHER OPTIONS CONSIDERED: Add a separate parameter to 
        VertexAttribPointer rather than alias the index parameter.
        Only advantage is slightly improved clarity.

        Add ClientActiveTexture protocol.  This would cause problems
        because the active texture is client state.  If two GLX processes
        were maintaining their own client state for one server-side
        context, it would be hard to reliably keep the active texture
        state in sync between the client and server.  It would need to be
        tracked per client on the server.

    How are Push/PopClientAttrib handled?

        RESOLVED: Specify protocol for these commands.  Some state
        affected by these commands needs to be duplicated in the server
        now, so these operations need to be duplicated there as well.

        OTHER OPTIONS CONSIDERED: Break the commands down into the
        individual commands required to perform the operation and send the
        appropriate protocol for those commands.  This is insufficient
        because it could cause deleted buffer objects to be destroyed by
        the server while they are still in use by a non-current entry in
        the client's attribute stack.

    How are integer arrays differentiated from floating point or fixed
    point arrays?

        RESOLVED: Added an "is_integer" boolean field to ARRAY_INFO and
        VertexAttribPointer.

    Is separate protocol needed for MapBuffer/UnmapBuffer?

        RESOLVED: Yes.  Buffers can only be mapped once.  Buffers need
        not be bound for the duration of their mapping, and whether a
        buffer is mapped or not is server state, so to properly track
        this state and generate related errors when there are multiple
        clients sharing the same buffer object, protocol must be sent
        to the server to duplicate the state there.

    Should the MapBuffer/UnmapBuffer protocol handle transferring of
    the buffer data when needed, or should implementations transfer the
    data using the BufferSubData and GetBufferSubData protocol?

        RESOLVED: Using the BufferSubData and GetBufferSubData protocol.
        This simplifies the Map and Unmap protocol and allows
        implementations to break up large data transfers into chunks.
        For example, the buffer data may be larger than the maximum size
        of a GLX single command.  Sending the data as part of the
        UnmapBuffer protocol would fail, but sending it in one or more
        BufferSubData commands would still be possible.  Implementations
        should take care to retreive the data, if needed, before mapping
        and send it back after unmapping.  This does not introduce race
        conditions because it is already up to the application to ensure
        proper mutexing of buffer object operations is done, and the
        protocol will still all happen within one application-visible GL
        command.

    Should client array data sent to the server in DrawArraysNew and
    DrawRangeElements be aligned?  Should individual arrays be separately
    aligned?  Should the arrays be sent be sent in order of largest
    element type to smallest?

        RESOLVED: No.  The client shall send the data as one contiguous
        array of bytes.  The server shall be responsible for aligning
        the individual entries as they are extracted if such alignment
        is needed.

    EXT_vertex_array allows enabling/disabling vertex arrays with
    Enable/Disable.  This state needs to be intercepted by the client
    to properly manage buffer object state.  Should protocol for Enable
    and Disable still be sent when these enums are used, or should the
    EnableClientState/DisableClientState protocol be sent instead?

        RESOLVED: Send the EnableClientState/DisableClientState protocol.
        The server may need to take additional actions for these special
        Enable/Disable enums.  Since the client already needs to
        intercept and handle them specially, keep the protocol separate
        for the server's benefit.

New Procedures and Functions

    void BindBufferARB(enum target, uint buffer);
    void DeleteBuffersARB(sizei n, const uint *buffers);
    void GenBuffersARB(sizei n, uint *buffers);
    boolean IsBufferARB(uint buffer);

    void BufferDataARB(enum target, sizeiptrARB size, const void *data,
                       enum usage);
    void BufferSubDataARB(enum target, intptrARB offset, sizeiptrARB size,
                          const void *data);
    void GetBufferSubDataARB(enum target, intptrARB offset,
                             sizeiptrARB size, void *data);

    void *MapBufferARB(enum target, enum access);
    boolean UnmapBufferARB(enum target);

    void GetBufferParameterivARB(enum target, enum pname, int *params);
    void GetBufferPointervARB(enum target, enum pname, void **params);

New Tokens


        GLX_CONTEXT_ALLOW_BUFFER_BYTE_ORDER_MISMATCH_ARB 0x2095


        ARRAY_BUFFER_ARB                             0x8892
        ELEMENT_ARRAY_BUFFER_ARB                     0x8893


        ARRAY_BUFFER_BINDING_ARB                     0x8894
        ELEMENT_ARRAY_BUFFER_BINDING_ARB             0x8895
        VERTEX_ARRAY_BUFFER_BINDING_ARB              0x8896
        NORMAL_ARRAY_BUFFER_BINDING_ARB              0x8897
        COLOR_ARRAY_BUFFER_BINDING_ARB               0x8898
        INDEX_ARRAY_BUFFER_BINDING_ARB               0x8899
        TEXTURE_COORD_ARRAY_BUFFER_BINDING_ARB       0x889A
        EDGE_FLAG_ARRAY_BUFFER_BINDING_ARB           0x889B
        SECONDARY_COLOR_ARRAY_BUFFER_BINDING_ARB     0x889C
        FOG_COORDINATE_ARRAY_BUFFER_BINDING_ARB      0x889D
        WEIGHT_ARRAY_BUFFER_BINDING_ARB              0x889E


        VERTEX_ATTRIB_ARRAY_BUFFER_BINDING_ARB       0x889F


        STREAM_DRAW_ARB                              0x88E0
        STREAM_READ_ARB                              0x88E1
        STREAM_COPY_ARB                              0x88E2
        STATIC_DRAW_ARB                              0x88E4
        STATIC_READ_ARB                              0x88E5
        STATIC_COPY_ARB                              0x88E6
        DYNAMIC_DRAW_ARB                             0x88E8
        DYNAMIC_READ_ARB                             0x88E9
        DYNAMIC_COPY_ARB                             0x88EA


        READ_ONLY_ARB                                0x88B8
        WRITE_ONLY_ARB                               0x88B9
        READ_WRITE_ARB                               0x88BA


        BUFFER_SIZE_ARB                              0x8764
        BUFFER_USAGE_ARB                             0x8765
        BUFFER_ACCESS_ARB                            0x88BB
        BUFFER_MAPPED_ARB                            0x88BC


        BUFFER_MAP_POINTER_ARB                       0x88BD


